"""
Environment Manager - Handle .env file operations for MCP server authentication

This module provides the EnvManager class for loading, saving, and managing
environment variables needed for MCP server authentication.
"""

import os
import re
from pathlib import Path
from typing import Dict, List, Optional


class EnvManager:
    """Manages environment variables from .env files."""

    def __init__(self, env_file: Optional[Path] = None):
        """
        Initialize environment manager.

        Args:
            env_file: Custom .env file path. Defaults to ~/.config/mcp-filter/.env
        """
        if env_file:
            self.env_file = Path(env_file)
        else:
            config_dir = Path.home() / ".config" / "mcp-filter"
            config_dir.mkdir(parents=True, exist_ok=True)
            self.env_file = config_dir / ".env"

    def load_env(self) -> Dict[str, str]:
        """
        Load environment variables from .env file.

        Returns:
            Dictionary of environment variable name -> value pairs
        """
        env_vars = {}

        if not self.env_file.exists():
            return env_vars

        try:
            with open(self.env_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    # Skip empty lines and comments
                    if not line or line.startswith('#'):
                        continue

                    # Parse KEY=VALUE format
                    if '=' in line:
                        key, value = line.split('=', 1)
                        key = key.strip()
                        value = value.strip()
                        # Remove quotes if present
                        if value.startswith('"') and value.endswith('"'):
                            value = value[1:-1]
                        elif value.startswith("'") and value.endswith("'"):
                            value = value[1:-1]
                        env_vars[key] = value
        except Exception as e:
            print(f"Warning: Could not read .env file: {e}")

        return env_vars

    def save_env(self, env_vars: Dict[str, str]) -> None:
        """
        Save environment variables to .env file.

        Args:
            env_vars: Dictionary of environment variable name -> value pairs
        """
        self.env_file.parent.mkdir(parents=True, exist_ok=True)

        try:
            with open(self.env_file, 'w') as f:
                f.write("# MCP Filter Environment Variables\n")
                f.write("# Generated by mcp-filter\n\n")
                for key, value in sorted(env_vars.items()):
                    # Quote values that contain spaces
                    if ' ' in value:
                        f.write(f'{key}="{value}"\n')
                    else:
                        f.write(f'{key}={value}\n')
        except Exception as e:
            print(f"Error: Could not write .env file: {e}")

    def get(self, key: str) -> Optional[str]:
        """
        Get a single environment variable.

        Checks both the .env file and system environment variables.

        Args:
            key: Environment variable name

        Returns:
            Variable value or None if not found
        """
        # Check system environment first
        sys_value = os.getenv(key)
        if sys_value:
            return sys_value

        # Check .env file
        env_vars = self.load_env()
        return env_vars.get(key)

    def set(self, key: str, value: str) -> None:
        """
        Set a single environment variable and save to .env file.

        Args:
            key: Environment variable name
            value: Environment variable value
        """
        env_vars = self.load_env()
        env_vars[key] = value
        self.save_env(env_vars)

    def prompt_for_missing(self, required_keys: list) -> Dict[str, str]:
        """
        Prompt user for missing environment variables and save them.

        Args:
            required_keys: List of environment variable names required

        Returns:
            Dictionary of env var names -> values (filled in from .env or user input)
        """
        if not required_keys:
            return {}

        result = {}
        current_env = self.load_env()
        needs_save = False

        print(f"\nðŸ”‘ Authentication required")
        print(f"The following environment variables are needed:\n")

        for key in required_keys:
            # Check if value exists in .env file or system env
            existing_value = self.get(key)

            if existing_value:
                print(f"  âœ“ {key} (already set)")
                result[key] = existing_value
            else:
                try:
                    value = input(f"  Enter {key} (or press Enter to skip): ").strip()
                    if value:
                        current_env[key] = value
                        result[key] = value
                        needs_save = True
                        print(f"    âœ“ Saved {key}")
                    else:
                        result[key] = ""
                        print(f"    âš ï¸  Skipped {key} (you'll need to set it later)")
                except (EOFError, KeyboardInterrupt):
                    print(f"\n    âš ï¸  Skipped remaining variables")
                    result[key] = ""

        # Save updated environment if any new values were added
        if needs_save:
            self.save_env(current_env)
            print(f"\nðŸ’¾ Saved to: {self.env_file}")

        return result

    def get_env_file_path(self) -> str:
        """Get the absolute path to the .env file."""
        return str(self.env_file.absolute())

    def extract_variables(self, command: str) -> List[str]:
        """
        Extract environment variable names from a command template.

        Looks for patterns like <VARIABLE_NAME> in the command string.

        Args:
            command: Command string that may contain <VARIABLE> placeholders

        Returns:
            List of unique variable names found in the command
        """
        # Find all matches of <VARIABLE_NAME> pattern
        matches = re.findall(r'<([A-Z_][A-Z0-9_]*)>', command)
        # Return unique variable names
        return list(set(matches))
