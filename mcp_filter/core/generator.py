"""
Code Generator - Generate filtered MCP server wrappers

This module provides the CodeGenerator class for creating Python wrapper scripts
that filter and combine tools from multiple MCP servers.
"""

import json
import os
from typing import Dict, List, Any


class CodeGenerator:
    """Generates filtered MCP server wrapper scripts."""

    @staticmethod
    def generate_wrapper_code(
        server_commands: Dict[str, str],
        selected_tools: List[Dict[str, Any]]
    ) -> str:
        """
        Generate Python code for a filtered MCP server wrapper.

        Args:
            server_commands: Dictionary mapping server names to their commands
            selected_tools: List of selected tool dictionaries with 'name' and 'server' keys

        Returns:
            Complete Python wrapper script as a string
        """
        tool_names = [tool['name'] for tool in selected_tools]

        # Group tools by server
        tools_by_server = {}
        for tool in selected_tools:
            server = tool.get('server', 'unknown')
            if server not in tools_by_server:
                tools_by_server[server] = []
            tools_by_server[server].append(tool['name'])

        wrapper_code = f'''#!/usr/bin/env python3
"""
Filtered MCP Server Wrapper
Auto-generated by mcp-filter
Combines tools from multiple MCP servers
"""
import json
import subprocess
import sys
from typing import Dict, List

ALLOWED_TOOLS = {json.dumps(tool_names, indent=4)}

# Server configurations
SERVERS = {json.dumps(server_commands, indent=4)}

# Tools grouped by server
TOOLS_BY_SERVER = {json.dumps(tools_by_server, indent=4)}

class MultiServerProxy:
    def __init__(self):
        self.processes = {{}}
        self.request_id = 0

    def start_servers(self):
        """Start all required MCP servers."""
        for server_name, command in SERVERS.items():
            if server_name in TOOLS_BY_SERVER:
                try:
                    process = subprocess.Popen(
                        command.split(),
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        stderr=sys.stderr,
                        text=True,
                        bufsize=1
                    )

                    # Initialize the server
                    init_request = {{
                        "jsonrpc": "2.0",
                        "id": 1,
                        "method": "initialize",
                        "params": {{
                            "protocolVersion": "2024-11-05",
                            "capabilities": {{}},
                            "clientInfo": {{"name": "mcp-filter", "version": "1.0.0"}}
                        }}
                    }}
                    process.stdin.write(json.dumps(init_request) + "\\n")
                    process.stdin.flush()
                    process.stdout.readline()  # Read init response

                    # Send initialized notification
                    initialized = {{"jsonrpc": "2.0", "method": "notifications/initialized"}}
                    process.stdin.write(json.dumps(initialized) + "\\n")
                    process.stdin.flush()

                    self.processes[server_name] = process
                except Exception as e:
                    print(f"Failed to start {{server_name}}: {{e}}", file=sys.stderr)

    def get_all_tools(self):
        """Retrieve all allowed tools from all servers."""
        all_tools = []
        for server_name, process in self.processes.items():
            try:
                tools_request = {{
                    "jsonrpc": "2.0",
                    "id": self.request_id,
                    "method": "tools/list",
                    "params": {{}}
                }}
                self.request_id += 1

                process.stdin.write(json.dumps(tools_request) + "\\n")
                process.stdin.flush()

                response_line = process.stdout.readline()
                response = json.loads(response_line)

                if "result" in response and "tools" in response["result"]:
                    server_tools = [
                        tool for tool in response["result"]["tools"]
                        if tool["name"] in TOOLS_BY_SERVER.get(server_name, [])
                    ]
                    all_tools.extend(server_tools)
            except Exception as e:
                print(f"Error getting tools from {{server_name}}: {{e}}", file=sys.stderr)

        return all_tools

    def route_request(self, request):
        """Route a tool call request to the appropriate server."""
        if request.get("method") == "tools/call":
            tool_name = request.get("params", {{}}).get("name")

            # Find which server has this tool
            for server_name, tool_list in TOOLS_BY_SERVER.items():
                if tool_name in tool_list and server_name in self.processes:
                    process = self.processes[server_name]
                    process.stdin.write(json.dumps(request) + "\\n")
                    process.stdin.flush()
                    response_line = process.stdout.readline()
                    return json.loads(response_line)

            return {{
                "jsonrpc": "2.0",
                "id": request.get("id"),
                "error": {{"code": -32601, "message": f"Tool {{tool_name}} not found"}}
            }}

        return None

    def shutdown(self):
        """Terminate all server processes."""
        for process in self.processes.values():
            process.terminate()

def main():
    proxy = MultiServerProxy()
    proxy.start_servers()

    try:
        for line in sys.stdin:
            request = json.loads(line)

            # Handle initialize request
            if request.get("method") == "initialize":
                response = {{
                    "jsonrpc": "2.0",
                    "id": request.get("id"),
                    "result": {{
                        "protocolVersion": "2024-11-05",
                        "capabilities": {{
                            "tools": {{}}
                        }},
                        "serverInfo": {{"name": "mcp-filter-multi", "version": "1.0.0"}}
                    }}
                }}
                sys.stdout.write(json.dumps(response) + "\\n")
                sys.stdout.flush()

            # Handle initialized notification
            elif request.get("method") == "notifications/initialized":
                pass  # No response needed

            # Handle tools/list request
            elif request.get("method") == "tools/list":
                all_tools = proxy.get_all_tools()
                response = {{
                    "jsonrpc": "2.0",
                    "id": request.get("id"),
                    "result": {{"tools": all_tools}}
                }}
                sys.stdout.write(json.dumps(response) + "\\n")
                sys.stdout.flush()

            # Handle tool calls
            elif request.get("method") == "tools/call":
                response = proxy.route_request(request)
                if response:
                    sys.stdout.write(json.dumps(response) + "\\n")
                    sys.stdout.flush()

            # Forward other requests to first available server
            else:
                if proxy.processes:
                    first_server = list(proxy.processes.values())[0]
                    first_server.stdin.write(line)
                    first_server.stdin.flush()
                    response_line = first_server.stdout.readline()
                    sys.stdout.write(response_line)
                    sys.stdout.flush()

    except KeyboardInterrupt:
        pass
    finally:
        proxy.shutdown()

if __name__ == "__main__":
    main()
'''
        return wrapper_code

    @staticmethod
    def save_wrapper(
        wrapper_code: str,
        output_file: str,
        make_executable: bool = True
    ) -> None:
        """
        Save wrapper code to file and optionally make it executable.

        Args:
            wrapper_code: Python code to save
            output_file: Path to output file
            make_executable: Whether to set executable permissions
        """
        with open(output_file, 'w') as f:
            f.write(wrapper_code)

        if make_executable:
            os.chmod(output_file, 0o755)

    @classmethod
    def generate_filtered_mcp(
        cls,
        server_commands: Dict[str, str],
        selected_tools: List[Dict[str, Any]],
        output_file: str
    ) -> None:
        """
        Generate a complete filtered MCP server wrapper.

        This is a convenience method that generates and saves the wrapper in one call.

        Args:
            server_commands: Dictionary mapping server names to their commands
            selected_tools: List of selected tool dictionaries with 'name' and 'server' keys
            output_file: Path to output file
        """
        wrapper_code = cls.generate_wrapper_code(server_commands, selected_tools)
        cls.save_wrapper(wrapper_code, output_file, make_executable=True)

        # Print summary
        tool_names = [tool['name'] for tool in selected_tools]
        tools_by_server = {}
        for tool in selected_tools:
            server = tool.get('server', 'unknown')
            if server not in tools_by_server:
                tools_by_server[server] = []
            tools_by_server[server].append(tool['name'])

        print(f"\nFiltered MCP server created: {output_file}")
        print(f"Included tools: {', '.join(tool_names)}")
        print(f"Servers used: {', '.join(tools_by_server.keys())}")
